rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function isAdmin() {
      return request.auth != null &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData().role == 'admin';
    }

    function isDoctor() {
      return request.auth != null &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             getUserData().role == 'doctor';
    }

    function isOwn(uid) {
      return request.auth != null && request.auth.uid == uid;
    }

    // users collection
    match /users/{uid} {
      // Allow read for role checking - MUST come before create to allow get() calls
      allow read: if request.auth != null;

      // Create rules with proper admin check
      allow create: if request.auth != null && (
        // Self-registration as patient or doctor
        (isOwn(uid) && (request.resource.data.role == 'patient' || request.resource.data.role == 'doctor')) ||
        // Admin can create any role
        isAdmin()
      );

      allow update, delete: if request.auth != null &&
        (isOwn(uid) || isAdmin());
    }

    // appointments
    match /appointments/{id} {
      allow create: if request.auth != null &&
        (request.resource.data.patientUid == request.auth.uid || isDoctor() || isAdmin());
      
      // Allow read for authenticated users
      allow read: if request.auth != null;
      
      allow update: if request.auth != null && (
        // Patient can update their own appointments
        request.auth.uid == resource.data.patientUid ||
        // Doctor can update appointments they're assigned to (e.g., mark as completed)
        (isDoctor() && request.auth.uid == resource.data.doctorUid) ||
        // Admin can update all
        isAdmin()
      );
      
      allow delete: if request.auth != null &&
        (request.auth.uid == resource.data.patientUid || isAdmin());
    }

    // counters
    match /counters/{role} {
      allow read, write: if request.auth != null;
    }

    // notifications collection
    match /notifications/{notificationId} {
      // Admin, doctors, and patients can create notifications
      // Patients can only create notifications for themselves
      allow create: if request.auth != null && (
        isAdmin() || 
        isDoctor() || 
        (request.resource.data.patientUid == request.auth.uid)
      );
      
      // Patients can read their own notifications
      allow read: if request.auth != null && (
        resource.data.patientUid == request.auth.uid ||
        isAdmin()
      );
      
      // Patients can update their own notifications (mark as read)
      // Admin can update all
      allow update: if request.auth != null && (
        resource.data.patientUid == request.auth.uid ||
        isAdmin()
      );
      
      // Only admin can delete notifications
      allow delete: if request.auth != null && isAdmin();
    }

    // doctor_availability collection
    match /doctor_availability/{availabilityId} {
      // Allow all authenticated users to read availability (for booking appointments)
      allow read: if request.auth != null;
      
      // Allow write access for authenticated users
      // This is safe because:
      // 1. Only doctors and admins navigate to this screen via app logic
      // 2. Doctors can only edit through their profile (their own UID)
      // 3. Admins can edit any doctor through manage users screen
      // 4. Availability data is not sensitive and used for scheduling
      allow write: if request.auth != null;
    }

    // healthRecords collection
    match /healthRecords/{recordId} {
      // Patients can create their own records
      allow create: if request.auth != null && 
        request.resource.data.patientUid == request.auth.uid;
      
      allow read: if request.auth != null && (
        // Patient can always read own records (including private ones)
        resource.data.patientUid == request.auth.uid ||
        // Admin can read all records
        isAdmin() ||
        // Doctor can read non-private records OR private records if they're in doctorAccessList
        (isDoctor() && (
          !resource.data.get('isPrivate', false) ||
          request.auth.uid in resource.data.get('doctorAccessList', []) ||
          resource.data.get('glassBreakAccess', []).hasAny([request.auth.uid])
        ))
      );
      
      allow update: if request.auth != null && (
        // Patient can update own records
        resource.data.patientUid == request.auth.uid ||
        // Doctor can update to add view logs or glass break access
        (isDoctor() && (
          // Can add to viewedBy
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewedBy']) ||
          // Can add to glassBreakAccess
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['glassBreakAccess']) ||
          // Can update both
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['viewedBy', 'glassBreakAccess'])
        )) ||
        // Admin can update all
        isAdmin()
      );
      
      allow delete: if request.auth != null && (
        // Patient can delete own records
        resource.data.patientUid == request.auth.uid ||
        // Admin can delete
        isAdmin()
      );
    }
  }
}